#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>

int arr[200] = { 0 };

#define MAX_QUEUE 100

typedef struct TreeNode {
    int val;
    struct TreeNode* left;
    struct TreeNode* right;
} TreeNode;
typedef struct {
    struct TreeNode* root;
    struct TreeNode* items[200];
}BTree;

void InitBTree(BTree* btree) {
    btree->root = btree->items[0];
}
// Queue 함수들
typedef struct {
    TreeNode* items[MAX_QUEUE];
    int front, rear;
} Queue;

void InitQueue(Queue* pqueue) {
    pqueue->front = pqueue->rear = -1;
}
bool isEmpty(Queue* queue) {
    return queue->front == -1;
}
bool isFull(Queue* pqueue) {
    return pqueue->front == (pqueue->rear + 1) % MAX_QUEUE;
}
void Enqueue(Queue* pqueue, TreeNode* root) {
    if (isFull(pqueue))
        exit(1);
    pqueue->rear = (pqueue->rear + 1) % MAX_QUEUE;
    pqueue->items[pqueue->rear] = root;
}
void Dequeue(Queue* pqueue) {
    if (isEmpty(pqueue))
        exit(1);
    pqueue->front = (pqueue->front + 1) % MAX_QUEUE;
}
TreeNode* Peek(Queue* pqueue) {
    if (isEmpty(pqueue))
        exit(1);
    else
        return pqueue->items[pqueue->front];
}

TreeNode* CreateNode(int val)
{
    TreeNode* newNode = (TreeNode*)malloc(sizeof(TreeNode));
    if (!newNode) exit(1);
    newNode->val = val;
    newNode->left = newNode->right = NULL;
    return newNode;
}
TreeNode* InsertNode(TreeNode* root, int val) {

}
//주어진 배열을 가지고 BinaryTree 가지치기 
bool isOneExists(TreeNode* root) {
    if (root == NULL)
        return false;
    bool leftIsOneExists = isOneExists(root->left);
    bool rightIsOneExists = isOneExists(root->right);

    if (!leftIsOneExists)
        root->left = NULL;
    if (!rightIsOneExists)
        root->right = NULL;

    return root->val == 1 || leftIsOneExists || rightIsOneExists;
}

//LevelOrder로 print 
void printBTree(TreeNode* root){
    Queue queue;
    InitQueue(&queue);
    Enqueue(&queue, root);

    while (!isEmpty(&queue))
    {
        root = Peek(&queue);
        Dequeue(&queue);

        printf("%d ", root->val);
        if (root->left != NULL)
            Enqueue(&queue, root->left);
        if (root->right != NULL)
            Enqueue(&queue, root->right);
    }
}

TreeNode* solution(TreeNode* root) {
    return root;
}

//레벨 순서를 따르는 배열을 이진 트리로 변환하는 함수 
void arrayToTree(TreeNode* root, int arr[]) {
    //배열의 첫 번째 요소는 루트 노드
		int arr2[201]={0};//삽입을 위한 새로운 배열 추가 
		for(int i=0;i<200;i++)
			arr2[i+1]=arr[i];//인덱스 하나씩 증가시키고 원소 복사
		
    Queue* pqueue;
    InitQueue(pqueue);
    root = CreateNode(arr[1]);
    Enqueue(pqueue, root);//pqueue 
    int i = 1;
    //주의 i의 인덱스는 1부터 200
    while (i<=201){
        root = Peek(pqueue);//root 에는 
        Dequeue(pqueue);//Dequeue 

        if(root->left!=NULL)
        {
            root->left = CreateNode(arr2[i*2]);
            Enqueue(pqueue, root->left);
        }
        if (root->right != NULL)
        {
            root->right = CreateNode(arr2[i * 2 + 1]);
            Enqueue(pqueue, root->right);
        }
			i++;
    }    
}

//TreeNode* insertValue(TreeNode* root, int val, TreeNode** q, int* front) {
//    TreeNode* node = CreateNode(val);//노드생성
//    if (root == NULL)
//        root = node;
//    else if (q[*front]->left == NULL)
//        q[*front]->left = node;
//    else {
//        q[*front]->right = node;
//        (*front)++;
//    }
//    q[*front] = node;
//    return root;
//}

/*reeNode* createTree(int arr[], int n) {
    TreeNode* root = NULL;
    TreeNode** queue = (TreeNode**)malloc(n * sizeof(TreeNode*));
    int front = 0;
    for (int i = 0; i < n; i++)
        root = insertValue(root, arr[i], queue, &front);
    free(queue);
    return root;
}*/

//TreeNode* buildTreeFromArray(int arr[]) {
//    // 첫 번째 요소를 루트로 설정하고 큐에 추가
//    TreeNode* root = CreateNode(arr[0]);
//    // 큐를 이용하여 노드를 연결해나감
//    int i = 1;
//    while (i < 200) {
//        TreeNode* cur = CreateNode(arr[i]);
//        i++;
//        // 현재 노드를 왼쪽 자식으로 연결
//        CreateLeftSubtree(root, cur);
//        // 다음 요소가 있는 경우 오른쪽 자식으로 연결
//        if (i < 200) {
//            cur = CreateNode(arr[i]);
//            i++;
//            createRightSubtree(root, cur);
//        }
//    }
//    return root;
//}
//void SetLeft(BTree* btree,int val,int parent_idx) {
//    TreeNode* newNode= CreateNode(val);
//    if (btree->items[parent_idx]->left != NULL)
//        exit(1);
//    btree->items[parent_idx]->left = newNode;
//}
//
//void SetRight(BTree* btree,int val, int parent_idx) {
//    TreeNode* newNode = CreateNode(val);
//    if (btree->items[parent_idx]->right != NULL)
//        exit(1);
//    btree->items[parent_idx]->right = newNode;
//}


int main() {
    //////
    int i = 0, cnt = 0;
    char str[400] = { 0 };
    char* s;

    scanf("%[^\n]", str);
    for (i = 2; i > 1; cnt += i > 0) {
        i = sscanf(str, "%d%*[ ]%[^\n]", &arr[cnt], str);
    }
    //// arr에 값이 저장됨.
    TreeNode* root;
    arrayToTree(root, arr);//배열을 Tree로 변환
    root= solution(root);
    //// print tree as array
		printBTree(root);

    return 0;
}
