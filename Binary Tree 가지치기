#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>

int arr[200] = { 0 };

#define MAX_QUEUE 100

typedef struct TreeNode{
    int val;
    struct TreeNode* left;
    struct TreeNode* right;
} TreeNode;

typedef struct {
    struct TreeNode* root;
    struct TreeNode* items[200];
}BTree;

// Queue 함수들
typedef struct {
    TreeNode* items[MAX_QUEUE];
    int front, rear;
} Queue;
void InitQueue(Queue* pqueue) {
    pqueue->front = pqueue->rear = -1;
}
bool isEmpty(Queue* queue) {
    return queue->front == -1;
}
bool isFull(Queue* pqueue) {
    return pqueue->front == (pqueue->rear + 1) % MAX_QUEUE;
}
void Enqueue(Queue* pqueue, TreeNode* root) {
    if (isFull(pqueue))
        exit(1);
    pqueue->rear = (pqueue->rear + 1) % MAX_QUEUE;
    pqueue->items[pqueue->rear] = root;
}
void Dequeue(Queue* pqueue) {
    if (isEmpty(pqueue))
        exit(1);
    pqueue->front = (pqueue->front + 1) % MAX_QUEUE;
}
TreeNode* Peek(Queue* pqueue) {
    if (isEmpty(pqueue))
        exit(1);
    else
        return pqueue->items[pqueue->front];
}

TreeNode* CreateNode(int val)
{
    TreeNode* newNode = (TreeNode*)malloc(sizeof(TreeNode));
    if (!newNode) exit(1);
    newNode->val = val;
    newNode->left = newNode->right = NULL;
    return newNode;
}

//주어진 배열을 가지고 BinaryTree 가지치기 
bool isOneExists(TreeNode* root) {
    if (root == NULL)
        return false;
    bool leftIsOneExists = isOneExists(root->left);
    bool rightIsOneExists = isOneExists(root->right);

    if (!leftIsOneExists) 
        root->left = NULL;
    if (!rightIsOneExists) 
        root->right = NULL;

    return root->val == 1 || leftIsOneExists || rightIsOneExists;
}

//LevelOrder로 print 
void printBTree(TreeNode* root) {
    Queue queue;
    InitQueue(&queue);
    Enqueue(&queue, root);//루트 노드 EnQueue

    while (!isEmpty(&queue))
    {
        root = Peek(&queue);
        Dequeue(&queue);

        printf("%d ", root->val);
        if (root->left != NULL)
            Enqueue(&queue, root->left);
        if (root->right != NULL)
            Enqueue(&queue, root->right);
    }
}

void solution(TreeNode* root){
    isOneExists(root);
}

//void CreateLeftSubtree(TreeNode* root, TreeNode* left) {
//    if (root->left!= NULL)//이미 존재한다면 
//        exit(1);
//    root->left = left;
//}
//
//void CreateRightSubtree(TreeNode* root, TreeNode* right) {
//    if (root->right!= NULL)//이미 존재한다면 
//        exit(1);
//    root->right= right;
//}

TreeNode* insertValue(TreeNode* root, int val,  TreeNode** q, int* front) {
    TreeNode* node = CreateNode(val);//노드생성
    if (root == NULL)
        root = node;
    else if (q[*front]->left == NULL)
        q[*front]->left = node;
    else {
        q[*front]->right = node;
        (*front)++;
    }
    q[*front] = node;
    return root;
}

 TreeNode* createTree(int arr[], int n) {
     TreeNode* root = NULL;
     TreeNode** queue = (TreeNode**)malloc(n * sizeof(TreeNode*));
    int front = 0;
    for (int i = 0; i < n; i++)
        root = insertValue(root, arr[i], queue, &front);
    free(queue);
    return root;
}

//TreeNode* buildTreeFromArray(int arr[]) {
//    // 첫 번째 요소를 루트로 설정하고 큐에 추가
//    TreeNode* root = CreateNode(arr[0]);
//    // 큐를 이용하여 노드를 연결해나감
//    int i = 1;
//    while (i < 200) {
//        TreeNode* cur = CreateNode(arr[i]);
//        i++;
//        // 현재 노드를 왼쪽 자식으로 연결
//        CreateLeftSubtree(root, cur);
//        // 다음 요소가 있는 경우 오른쪽 자식으로 연결
//        if (i < 200) {
//            cur = CreateNode(arr[i]);
//            i++;
//            createRightSubtree(root, cur);
//        }
//    }
//    return root;
//}

//void SetLeft(BTree* btree,int val,int parent_idx) {
//    TreeNode* newNode= CreateNode(val);
//    if (btree->items[parent_idx]->left != NULL)
//        exit(1);
//    btree->items[parent_idx]->left = newNode;
//}
//
//void SetRight(BTree* btree,int val, int parent_idx) {
//    TreeNode* newNode = CreateNode(val);
//    if (btree->items[parent_idx]->right != NULL)
//        exit(1);
//    btree->items[parent_idx]->right = newNode;
//}


 int main() {
	  //////
    int i = 0, cnt = 0;
    char str[400] = { 0 };
    char* s;

    scanf("%[^\n]", str);
    for (i = 2; i > 1; cnt += i > 0) {
        i = sscanf(str, "%d%*[ ]%[^\n]", &arr[cnt], str);
    }
		//// arr에 저장된다. 
    TreeNode* root = CreateNode(arr[i]);
    BTree* btree = (BTree*)malloc(sizeof(BTree));
    btree->root = CreateNode(arr[i]);

    //for (i = 0; i < 200; i=i*2)
    //{
    //    //Set함수(트리, 값, 부모 인덱스)
    //    SetLeft(btree,arr[i], i);
    //    SetRight(btree,arr[i], i + 1);
    //}

    for (i = 0; i < 200; i++)
        printf("%d  ", arr[i]);

    solution(btree->root);

    //// print tree as array
    printBTree(root);
	 
    free(root);
    free(btree);
    return 0;
}
